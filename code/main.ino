/**
  * Description: Memory game using Arduino, made for TEJ3M0 Arduino Project
  * Author: Aritro Saha
  * Last Edited: 2022/12/03
*/

// Gets the size of any array
#define LEN(ARR) (int) (sizeof(ARR) / sizeof(ARR[0]))

// Initialize array of pins in order
#define PIN_MODE_ITER(ARR, TYPE) for (int _ = 0; _ < LEN(ARR); _++) pinMode(ARR[_], TYPE); 

// Pins for the decoder
#define DECODER_1_PIN 3
#define DECODER_2_PIN 6
#define DECODER_3_PIN 5
#define DECODER_4_PIN 4

// Pins for all 4 LEDs
#define LED_1_PIN 10
#define LED_2_PIN 9
#define LED_3_PIN 8
#define LED_4_PIN 7

// Colors of all 4 LEDs
#define LED_1_COLOR "Red"
#define LED_2_COLOR "Blue"
#define LED_3_COLOR "Orange"
#define LED_4_COLOR "Yellow"

// Pins for all 4 buttons
#define BTN_1_PIN A0
#define BTN_2_PIN A1
#define BTN_3_PIN A2
#define BTN_4_PIN A3

// Speaker pin
#define SPEAKER_PIN 11

// Maximum # of levels before game end
#define MAX_LEVELS 10

// Whether to send prompt to serial. Disable if it glitches (does so in TinkerCAD)
#define SHOW_SERIAL_PROMPT false

int level = 1;
bool waitingForInput = false;

// Pins for sets of components
const int LED_PINS[] = {LED_1_PIN, LED_2_PIN, LED_3_PIN, LED_4_PIN};
const int BTN_PINS[] = {BTN_1_PIN, BTN_2_PIN, BTN_3_PIN, BTN_4_PIN};
const int DECODER_PINS[] = {DECODER_1_PIN, DECODER_2_PIN, DECODER_3_PIN, DECODER_4_PIN}; // In order from LSB to MSB

// Important tones in game
const int GAME_OVER_TONES[] = {294, 277, 262, 247}; // D, C#, C, B
const int FINISHED_TONES[] = {262, 330, 294, 392, 523}; // C, E, D, G, HighC
const int BTN_PRESS_TONES[] = {261, 294, 330, 349}; // C, D, E, F

// Colors of each LED, in same order as LED_PINS
const char* LED_COLORS[] = {LED_1_COLOR, LED_2_COLOR, LED_3_COLOR, LED_4_COLOR};

// Header def of func below, scroll down for more info
void numToBCD(int num);

void setup() {  
  Serial.begin(9600);
  Serial.println("\n-- MEMORY GAME --\n");
  
  // Show info about the game in serial. Disable through definition.
  if (SHOW_SERIAL_PROMPT) {
    Serial.println("Made by: Aritro, Byron, Haris");
    Serial.println("Course: TEJ3M0");
    Serial.println("Submission date: November 5, 2022");
    Serial.println("You'll be able to see debug info here.");
    Serial.println("  Specifically, the sequence of colors generated by the Arduino, and button presses.");
    Serial.println("  If the colors look incorrect, make sure to adjust the color definitions at the top of the file.");
    Serial.println("Have fun!");
  }
  
  // Initialize all sets of pins needed 
  PIN_MODE_ITER(DECODER_PINS, OUTPUT);
  PIN_MODE_ITER(LED_PINS, OUTPUT);
  PIN_MODE_ITER(BTN_PINS, INPUT);
  
  // Initialize speaker pin
  pinMode(SPEAKER_PIN, OUTPUT);
  
  // Seed the random generator from random noise
  randomSeed(analogRead(A5));
  
  // Countdown to start
  for (int i = 3; i >= 1; i--) {
    // Update display with countdown
    numToBCD(i);
    
    // Play G4 for 1s
    tone(SPEAKER_PIN, 392);
    delay(750);
    noTone(SPEAKER_PIN);
    
    // Wait for 200ms before going to next one
    delay(200);
  }

  // Update the display to show the current level
  numToBCD(level - 1);
  
  // Play G5 for 1s
  tone(SPEAKER_PIN, 784);
  delay(1000);
  noTone(SPEAKER_PIN);
  
  // Wait a bit before actually starting game
  delay(500);
}

void loop() {
  // User is done game
  if (level > MAX_LEVELS) {
    // Turn on all LEDs
    for (int i = 0; i < LEN(LED_PINS); i++)
      digitalWrite(LED_PINS[i], HIGH);
    
    // Play completion tone
    for (int i = 0; i < LEN(FINISHED_TONES); i++) {
      tone(SPEAKER_PIN, FINISHED_TONES[i]);
      delay(500);
      noTone(SPEAKER_PIN);
    }
    
    // Turn off all LEDs
    for (int i = 0; i < LEN(LED_PINS); i++)
      digitalWrite(LED_PINS[i], LOW);
    
    // Set level to 1 and update display
    numToBCD(level = 1);
    
    // Wait 3 seconds before staring new level
    delay(3000);
  }
    
  // Play random sequence of LEDs based on level number
  int sequence[MAX_LEVELS];
  Serial.println("Sequence:");
  for (int i = 0; i < level; i++) {
    // Get random number
    sequence[i] = random(0, 4);
    
    // Send actual color to serial
    Serial.println(LED_COLORS[sequence[i]]);
    
    // Get the LED pin and speaker tone to play
    int ledPin = LED_PINS[sequence[i]];
    int speakerTone = BTN_PRESS_TONES[sequence[i]];
    
    // Turn on LED and play tone for 350ms
    digitalWrite(ledPin, HIGH);
    tone(SPEAKER_PIN, speakerTone);
    delay(350);
    noTone(SPEAKER_PIN);
    digitalWrite(ledPin, LOW);
    
    // Wait a bit before playing the next tone
    delay(300);
  }
  Serial.println();
  
  bool userCorrect = true;
  // Actual color they should've pressed (only changed if user wrong)
  int actualBtnLedPIN = -1;
  
  for (int i = 0; i < level; i++) {
    // Wait until a button is pressed
    Serial.println("Waiting for button press...");
    while (!digitalRead(BTN_1_PIN) && !digitalRead(BTN_2_PIN) && !digitalRead(BTN_3_PIN) && !digitalRead(BTN_4_PIN));
    Serial.println("Button press received!");
    
    // Find out which button was pressed
    int btnPressed = 0;
    for (int btnToCheck = 0; btnToCheck < LEN(BTN_PINS); btnToCheck++) {
      if (digitalRead(BTN_PINS[btnToCheck])) {
        btnPressed = btnToCheck;
        break;
      }
    }
    
    // Log received input and actual color in sequence to serial
    Serial.print("Button pressed: ");
    Serial.println(LED_COLORS[btnPressed]);
    Serial.print("Correct button: ");
    Serial.println(LED_COLORS[sequence[i]]);
    Serial.println(); // New line to keep things nicely formatted
    
    // Immediately stop if incorrect
    if (sequence[i] != btnPressed) {
      userCorrect = false;
      
      // Show LED corresponding to correct button
      digitalWrite(LED_PINS[sequence[i]], HIGH);
      actualBtnLedPIN = LED_PINS[sequence[i]];
      break;
    }
    
    // Play corresponding tone and turn on LED if it's correct for 300ms
    tone(SPEAKER_PIN, BTN_PRESS_TONES[sequence[i]]);
    digitalWrite(LED_PINS[btnPressed], HIGH);
    delay(300);
    digitalWrite(LED_PINS[btnPressed], LOW);
    noTone(SPEAKER_PIN);
  }
  
  // Wait 500ms
  delay(500);
  
  if (!userCorrect) {
    // User got it wrong, go back to first level
    Serial.println("Player is wrong :(");
    
    // Play first 3 notes of "womp womp womp woommmppp" tone (great comment)
    for (int i = 0; i < LEN(GAME_OVER_TONES); i++) {
      tone(SPEAKER_PIN, GAME_OVER_TONES[i]);
      delay(1000);
      noTone(SPEAKER_PIN);
    }
    
    // Before playing last note, turn off the correct LED
    digitalWrite(actualBtnLedPIN, LOW);
    
    // Continue playing the last note
    tone(SPEAKER_PIN, GAME_OVER_TONES[3]);
    delay(1000);
    noTone(SPEAKER_PIN);
    
    // Turn on and off the LEDs
    for (int i = 0; i < LEN(LED_PINS) * 2; i++) {
      digitalWrite(LED_PINS[i % LEN(LED_PINS)], !(i / LEN(LED_PINS)));
      delay(250);
    }
    
    // Reset the level
    level = 1;
  } else {
    // User succesfully passed level, go to next
    Serial.println("Player is correct :)");
    level++;
  }
  
  // Keep new line in log
  Serial.println();
  Serial.println();
  
  // Update score display
  numToBCD(level - 1);
  delay(500);
}

// Update the decoder that controls the 7 segment display
void numToBCD(int num) {
  num = max(0, min(num, 9)); // Decoder does not output when n<0 and n>9
  for (int i = 0; i < LEN(DECODER_PINS); i++) {
    digitalWrite(DECODER_PINS[i], bitRead(num, i));
  }
}
